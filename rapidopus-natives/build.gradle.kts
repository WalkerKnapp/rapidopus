import de.undercouch.gradle.tasks.download.Download
import org.gradle.internal.os.OperatingSystem

apply {
    from("../toolchains.gradle.kts")
}

plugins {
    `cpp-library`
    id("de.undercouch.download") version "4.0.4"
}


val downloadJniHeader by tasks.registering(Download::class) {
    src("https://raw.githubusercontent.com/openjdk/jdk/master/src/java.base/share/native/include/jni.h")
    dest(temporaryDir)
    outputs.dir(temporaryDir)
}

val downloadJniMdHeaderUnix by tasks.registering(Download::class) {
    src("https://raw.githubusercontent.com/openjdk/jdk/master/src/java.base/unix/native/include/jni_md.h")
    dest(temporaryDir)
    outputs.dir(temporaryDir)
}

val downloadJniMdHeaderWindows by tasks.registering(Download::class) {
    src("https://raw.githubusercontent.com/openjdk/jdk/master/src/java.base/windows/native/include/jni_md.h")
    dest(temporaryDir)
    outputs.dir(temporaryDir)
}

tasks.withType(CppCompile::class).configureEach {
    compilerArgs.addAll(toolChain.map { toolChain ->
        when (toolChain) {
            is VisualCpp -> listOf("/std:c++11")
            is GccCompatibleToolChain -> listOf("-lstdc++", "-std=c++11", "-static-libgcc", "-static-libstdc++", "-fPIC")
            else -> listOf()
        }
    })

    compilerArgs.addAll(toolChain.map { toolChain ->
        if (this@configureEach.name.toLowerCase().contains("debug")) {
            when (toolChain) {
                is VisualCpp -> listOf("/MDd")
                else -> listOf()
            }
        } else {
            when (toolChain) {
                is VisualCpp -> listOf("/MD")
                else -> listOf()
            }
        }
    })
}

tasks.withType(LinkSharedLibrary::class).configureEach {
    linkerArgs.addAll(toolChain.map { toolChain ->
        when (toolChain) {
            is GccCompatibleToolChain -> listOf("-fstack-protector-strong")
            else -> listOf()
        }
    })
}

library {
    targetMachines.set(listOf(
            machines.windows.x86, machines.windows.x86_64,
            machines.macOS.x86_64,
            machines.linux.x86, machines.linux.x86_64,
            machines.os("android").architecture("armv7a"),
            machines.os("android").architecture("arm64-v8a"),
            machines.os("android").x86,
            machines.os("android").x86_64))

    // Include JNI headers generated by devolay-java
    val headerOnly: Configuration by configurations.creating {}
    dependencies {
        headerOnly(project(":rapidopus-java", "jniIncludes"))

        implementation("org.opus-codec:opus")
    }

    privateHeaders {
        from(headerOnly)

        // Include platform-independent JNI Path
        from(downloadJniHeader)
    }

    binaries.whenElementFinalized {
        if (this.targetMachine.operatingSystemFamily.isWindows) {
            this.compileTask.get().dependsOn(downloadJniMdHeaderWindows)
            this.compileTask.get().includes.from(downloadJniMdHeaderWindows)
        } else {
            this.compileTask.get().dependsOn(downloadJniMdHeaderUnix)
            this.compileTask.get().includes.from(downloadJniMdHeaderUnix)
        }
    }
}


// Add artifacts for rapidopus-java to depend on
val assembleNativeArtifacts by tasks.registering(Jar::class) {
    archiveBaseName.set("rapidopus-native-artifacts")
    destinationDirectory.set(temporaryDir)

    components.withType(ComponentWithBinaries::class).forEach { component ->
        (component as ComponentWithBinaries).binaries.whenElementFinalized(ComponentWithOutputs::class.java) {
            if (this is ComponentWithNativeRuntime) {
                val machine = this.targetMachine

                // Only include release binaries
                if (this.isOptimized && !this.getName().toLowerCase().contains("debug")) {
                    from(this.outputs) {
                        into("natives/" + machine.operatingSystemFamily.name + "/" + machine.architecture.name)
                        exclude("*.lib")
                        exclude("*.debug")

                        if (machine.operatingSystemFamily.name == "android") {
                            rename { it.subSequence(0, it.lastIndexOf('.')).toString() + ".androidnative" }
                        }
                    }
                }
            }
        }
    }
}

val nativeArtifacts: Configuration? by configurations.creating {
    isCanBeConsumed = true
    isCanBeResolved = false
}

artifacts {
    add("nativeArtifacts", assembleNativeArtifacts)
}
